'''
다이나믹 프로그래밍은 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법.
• 의미 계산된 결과(작은 문제)는 나중에 해당 결과가 필요할 때, 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 하는 방법.
• 다이나믹 프로그래밍의 구현은 일반적으로 두 가지 방식(탑다운과 보텀업)으로 구성됨.

한번 계산된 결과를 메모이제이션(Memoization)하고 다시 계산하지 않음.!
완전탐색시 비효율적이어도 다이나믹으로 효율화 할 수 있음.

다이나믹 프로그래밍은 동적 계획법이라고도 부릅니다.
•자료구조에서 동적 할당(Dynamic Allocation)은 '프로그램이 실행되는 도중에 실행에 필요한 메모리를 할당하는 기법'을 의미하지만
반면에 다이나믹 프로그래밍에서 '다이나믹'은 별다른 의미 없이 사용된 단어라고 함;

다이나믹 프로그래밍은 문제가 다음의 조건을 만족할 때 사용할 수 있습니다.
1. 최적 부분 구조 (Optimal Substructure)
• 큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있습니다.
2. 중복되는 부분 문제 (Overlapping Subproblem)
• 동일한 작은 문제를 반복적으로 해결해야 합니다.
'''

'''
피보나치 수열
• 피보나치 수열 다음과 같은 형태의 수열이며, 다이나믹 프로그래밍으로 효과적으로 계산할 수 있습니다.
1,1,2,3,5,8,13,21,34,55,89,
• 점화식이란 인접한 항들 사이의 관계식을 의미합니다.
• 피보나치 수열을 점화식으로 표현하면 다음과 같습니다.
a[n] = a[n-1], + a[n-2]. 
a[1] = 1, a2 = 1 알면 구할 수 있음.

앞 두수를 합한 an. 
수열을 배열이나 리스트를 이용해 표현.
무한 루프를 돌지않도록 종료 조건을 명시해야함.
'''
# 재귀함수를 이용한 피보나치 수열
# 종료조건을 명시해야하는데 피보나치는 앞에 1번째, 2번째가 모두 1이기 때문에 1,2일때 1을 반환하도록 함.
'''
단순 재귀함수로 피보나치 수열을 구현하면 지수 시간 복잡도를 갖게 되어 비효율적임.
중복되는 부분 문제.
f(6)호출시 f(2)가 여러번 호출됨. 한번 계산된 결과는 재계산되지 않도록 해야함.
6
5       4
4 3    3 2
32 21 21
21

O2^n 시간복잡도.
'''
def fibo(n):
    if n == 1 or n == 2:
        return 1
    return fibo(n-1) + fibo(n-2) # 앞, 앞앞의 수를 더함.

print(fibo(4))

'''
피보나치는 아래 두조건을 만족하여 다이나믹사용조건 만족함.
1. 최적 부분 구조
    큰 문제를 작은 문제로 나눌 수 있으며 작은 문제의 답을 모아서 큰 문제를 해결할 수 있습니다.
2. 중복되는 부분 문제
    동일한 작은 문제를 반복적으로 해결해야 합니다.

구현
1. 탑다운
메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 하나입니다.
한 번 계산한 결과를 메모리 공간에 메모하는 기법입니다.
• 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져옵니다.
• 값을 기록해 놓는다는 점에서 캐싱(Caching)이라고도 합니다.

2. 보텀업
'''

'''
탑다운 VS 보텀업
• 탑다운(메모이제이션) 방식은 하향식이라고도 하며 -> 재귀 함수 사용
보텀업 방식은 상향식이라고도 합니다. -> 반복문 사용
• 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식입니다.
• 결과 저장용 리스트는 DP 테이블이라고 부릅니다.
• 엄밀히 말하면 메모이제이션은 이전에 계산된 결과를 일시적으로 기록해 놓는 넓은 개념을 의미합니다.
• 따라서 메모이제이션은 다이나믹 프로그래밍에 국한된 개념은 아닙니다.
• 한 번 계산된 결과를 담아 놓기만 하고 다이나믹 프로그래밍을 위해 활용하지 않을 수도 있습니다.
'''

# 탑다운 다니아믹 프로그래밍 - 피보나치 수열 구현
dp = [0] * 100 # 메모이제이션을 위한 리스트 초기화
def fibo_dp(x):
    # 종료 조건 1혹은 2일때 1을 반환
    if x == 1 or x == 2:
        return 1
    # 이미 계산한 적이 있으면 그대로 반환
    if dp[x] != 0:
        return dp[x]
    # 계산한적이 없으면 점화식에 따라 계산하고 메모이제이션, 피보나치 결과 반환
    dp[x] = fibo_dp(x - 1) + fibo_dp(x - 2)
    return dp[x]

print(fibo_dp(99))
